<h1 align=center>CT Backend Engineer Exercise</h1>

<p align=center>
  <img src="./assets/header_image.png" height=200 />
</p>

***<p align=center>Exercise requirements outlined in [this gist](https://gist.github.com/adilasif/85aee271cd4041212ed8fffead2ef40c).</p>***

### <p align=center>[![adilasif](https://circleci.com/gh/adilasif/ct-backend-engineer-exercise.svg?style=shield&circle-token=3e5476f961d55ca8224828fea1e76ea0dfce8bee)](https://circleci.com/gh/adilasif/ct-backend-engineer-exercise)</p>

<h2 align=center>Introduction & Initial Thoughts</h2>

***Hello, commercetools team!*** :smile:

#### Assumptions

From looking at the gist that was provided to me, I've made the following assumptions:

* For the purposes of this exercise, and in the interest of not spending time writing a simple Express endpoint (with logging and such additional baggage that comes along with *Doing It Right*), the application itself should be a simple utility that can be run to generate a report, and does not need to be a web server exposing a REST endpoint.
* The application itself does not need to retrieve, find, or generate Etsy shop IDs, and should simply accept shop IDs as an argument at runtime.
* The application should save each passed shop's listings into a flat file named for the shop in a machine-readable format (JSON).
* The application should output a diff of the listings for each given shop since the last time the application was run with a given shop passed as an argument.
* The list of shop IDs will be passed as an array.
* Only active listings are considered important for each shop.

With those assumptions in mind, it is my understanding that at a high level, the application needs to:

1. Check if a file for each shop already exists.
2. Retrieve the active listings of each shop passed as an argument.
3. If a file for a given shop exists, compare the listings saved in that file to the newly retrieved listings for that shop, returning a difference object.
4. Save the updated listings to a flat file as JSON, overwriting any existing files.
5. Once there are no more shops to retrieve and compare listings for, print the list of differences for each shop to STDOUT.

<h2 align=center>Local Project Setup</h2>

#### Prerequisites:

  * [Node.js ^12.14.x (lts)](https://nodejs.org/en/)
  * Node.js package manager of your choice (NPM or Yarn)

#### Installation:
1. Clone the project to your chosen directory.
2. From the project root directory, run `npm install` or `yarn`.
3. Copy the `.env.example` file at the project's root directory, rename the copy to `.env` and insert your Etsy API key into the environment variable `ETSY_API_KEY`.

That's all that's needed in order to run it locally. You can run it in your terminal with `npm run dev` or `yarn dev`.

> üìù This application uses `import` syntax instead of commonjs syntax, so the launch script uses babel-node. Likewise, to generate a "production" build, you will need to run the build command `npm run build` or `yarn build` in order to generate a transpiled version of the application. If you decide to build it, you will find the result in the `./dist` directory. You can then run the built application using `node ./dist/index.js`.

<h2 align=center>Project Structure</h2>

```
/                     -- Project root. Contains the src directory and various configuration files.
|--item-listings      -- The JSON files generated to store each Etsy shop's listings go here.
|--src                -- All the application code lives in here.
  |--__tests__        -- Here there be unit tests.
  |--core             -- All the main business logic of the application can be found here.
  |--index.js         -- This is the entrypoint for the app, and where the main function is declared and invoked.
```

<h2 align=center>Notes</h2>

#### Challenges and Tradeoffs

Deciding on an approach to handle the data and generate the diffs took a bit of thought.

First, I decided to store only the data needed for the application to work, and eliminate all the unnecessary metadata from the saved listings. The resulting JSON looked like this:

```json
{
  "listings": [
    {
      "listing_id": 123456789,
      "title": "Listing Title 2"
    },
    {
      "listing_id": 123456788,
      "title": "Listing Title 1"
    }
  ],
  "shopID": 123456789
}
```

With a total time limit of ~4-5 hours, I didn't want to take the time to implement and test a diff method myself, so off I went to the one-stop-shop of one-off methods, NPM, and looked at a few packages.

My first instinct was to use a normal diff method, like the [diff](https://www.npmjs.com/package/diff) package exports, and in fact, I built out out the rest of the application's functionality using that package before switching to what I ultimately went with.

When it came to using the diff objects generated by that library, I got sucked into a hole of trying to -- and I can't believe I'm telling you this, because I'm actually rather embarrassed by it -- figure out how to retrieve the values I needed (the `listing_id` and `title` from strings that were themselves invalid JSON (and thus couldn't be easily parsed into objects). I got so far as to write two bits of regular expression "wizardry" to coax values from strings that looked a lot like...

```
 \"listing_id\": 123456789, 
        \"title\": \"Listing title... that can contain escaped quotes\"
      },
```

...before realizing that what I was about to waste a whole bunch of time on a problem that could really use some more careful thought and a more methodical approach.

Since the rest of the app's functionality was more or less done, I looked at my remaining time and decided that I could afford to stop and think about how I wanted to store and compare the data, and parse the comparison into strings.

After a bit of deliberation, I decided that using a longest common subsequence based character diff algorithm was simply a poor choice for the problem at hand, and that I should revisit the data structure I'm using to save the data.

Since I'm only saving the data needed for the application -- and thus not to be reused by another service at this point -- I should refactor the function that generates the listing files to generate a flat data structure containing only the essential information for each listing. Instead of saving listings as an array of objects, it makes more sense to treat the files like a database, and save whatever information I want for each listing with it'd ID as its key.

The refactor resulted in the saved listings looking like this:

```json
{
  "listings": {
    "123456789": "Listing Title 2",
    "123456788": "Listing Title 1"
  },
  "shopID": 123456789
}
```

Much better! This has the benefit of not forcing the application to iterate through an array, and to more easily see if a listing title was edited on refreshing the data. This is a far more scalable solution as either the number of listings or the number of stores being updated and diffed at a time grows.

Before settling in to flex my algorithm muscles and write my own graph traversal and comparison function, I decided to look around on NPM one more time. I found another [diff module](https://www.npmjs.com/package/deep-diff) that both returned the diff information in a machine-friendly data structure, and is also lighter weight, with 0 dependencies. Excellent!

I went ahead and installed it, and a few minutes of config and shuffling around code was all it took to make the app work to spec.

>**Warning: Pointless digression about (premature) performance optimization ahead. Feel free to skip this part!**
>
>*Seriously, it's pointless. I only put this in here because I spent a not-neglible amount of time playing with this to satisfy my curiosity.*
>
>At this point, I went ahead and finished the original diff and parser functions using RegEx to compare performance. I threw together some mock datasets with hundreds and then thousands of entries per shop, and let the app run. Much to my surprise, the RegEx method was not particularly slow!
>
>I'm only a novice when it comes to crafting regular expressions, so though RegEx parsing is potentially O(N), mine very likely aren't.
>
>Regardless, on my machine, until the application passed 4000 entries per shop or so, the longest part was still the HTTP request to the Etsy API. The method I settled on did perform measurably better, but not vastly. The first diff NPM package uses Myers' longest common subsequence algorithm, which realistically has a polynomial runtime complexity - O(N), with a theoretical worst-case of O(NlogN). I know the diff package I ultimately went with compares objects using a preorder tree traversal (which is also polynomial). With that in mind, I'd imagine that perhaps the most performant *initial* solution would be to use the first diff package, and do something like...
>
```js
const jsonString = " \"listing_id\": 123456789,       \"title\": \"Listing title\"      }";

// Find the number of characters in the listing_id's value;
// all that I've seen have 9, but it's a sequential integer,
// so it's only a matter of time.
const endOfID = jsonString.indexOf(',', 17); // 26

const lengthOfListingID = endOfID - 17; // 9

const listingID = jsonString.subStr(17, lengthOfListingID); // 12356789
```
>
>...with a similar technique to retrieve the title; though the performance of that versus optimized RegEx would depend on how the `subStr` and `indexOf` methods are implemented under the hood... And frankly, it's irrelevant for this application anyway except for the fact that this is an interview.
>
> **/digression**

With time left over, I started thinking about edge cases. What if a listing's title was updated? I'm not sure if Etsy allows that, or if it requires one to take down the item and repost it (thus assigning a new item ID), but I decided it would make sense to add a string for an updated listing, so I did so.

Another consideration was what to do if something happens to one or all of the saved files? If someone tried to delete the data by deleting the file's contents, leaving behind an empty file, `JSON.parse()` wouldn't work... And to tackle that and potential invalid/corrupted JSON at the same time, I decided to add a JSON validator function.

At this point, I was coming up on the time limit, and decided that if I'm going to be writing more code, it should probably be adding some simple unit tests.

#### What I'm Most Proud Of

I'm quite happy with the app's simplicity, honestly. There's no complicated code in the application, in my opinion, and I believe that anyone familiar with ES6 can understand what each module does fairly quickly, even in isolation.

Of course, I may be somewhat biased in that regard.

I'm also quite pleased with the solution used to generate the diffs and parse them into strings, though it's really rather obvious in hindsight.

#### What I'm Least Proud Of

Hands down the fact that I not only used that first [diff library](https://www.npmjs.com/package/diff), but also started to actually write a parser using regular expressions **before taking a moment to reflect on what I was doing**. That's a good reminder for me to take a step back and really think through my solution before I start writing code. Though to be fair, it *did* work, and *did* solve the problem.

Also, I should have spent some more time planning and implementing unit tests and especially integration tests; this application would very much benefit from integration testing.

#### Miscellaneous Extra Info

This app has effectively no error handling. I catch errors where they're likely to occur, but I'm just logging them to the console.
